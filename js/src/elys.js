// ----------------------------------------------------------------------------

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code
// EDIT THE CORRESPONDENT .ts FILE INSTEAD

//  ---------------------------------------------------------------------------
import Exchange from './abstract/elys.js';
import { ArgumentsRequired } from './base/errors.js';
import { TICK_SIZE } from './base/functions/number.js';
//  ---------------------------------------------------------------------------
/**
 * @class elys
 * @augments Exchange
 */
export default class elys extends Exchange {
    describe() {
        return this.deepExtend(super.describe(), {
            'id': 'elys',
            'name': 'Elys Network',
            'countries': ['US'],
            'version': 'v1',
            'rateLimit': 100,
            'certified': false,
            'pro': false,
            'dex': true,
            'has': {
                'CORS': undefined,
                'spot': true,
                'margin': false,
                'swap': true,
                'future': true,
                'option': false,
                'addMargin': false,
                'borrowCrossMargin': false,
                'borrowIsolatedMargin': false,
                'cancelAllOrders': false,
                'cancelAllOrdersAfter': false,
                'cancelOrder': false,
                'cancelOrders': false,
                'cancelOrdersForSymbols': false,
                'closeAllPositions': false,
                'closePosition': false,
                'createMarketBuyOrderWithCost': false,
                'createMarketOrderWithCost': false,
                'createMarketSellOrderWithCost': false,
                'createOrder': false,
                'createOrders': false,
                'createOrderWithTakeProfitAndStopLoss': false,
                'createReduceOnlyOrder': false,
                'createStopOrder': false,
                'createTriggerOrder': false,
                'editOrder': false,
                'editOrders': false,
                'fetchAccounts': false,
                'fetchBalance': true,
                'fetchBorrowInterest': false,
                'fetchBorrowRateHistories': false,
                'fetchBorrowRateHistory': false,
                'fetchCanceledAndClosedOrders': false,
                'fetchCanceledOrders': false,
                'fetchClosedOrders': false,
                'fetchCrossBorrowRate': false,
                'fetchCrossBorrowRates': false,
                'fetchCurrencies': true,
                'fetchDepositAddress': false,
                'fetchDepositAddresses': false,
                'fetchDeposits': false,
                'fetchDepositWithdrawFee': false,
                'fetchDepositWithdrawFees': false,
                'fetchFundingHistory': false,
                'fetchFundingRate': false,
                'fetchFundingRateHistory': false,
                'fetchFundingRates': false,
                'fetchIndexOHLCV': false,
                'fetchIsolatedBorrowRate': false,
                'fetchIsolatedBorrowRates': false,
                'fetchLedger': false,
                'fetchLeverage': false,
                'fetchLeverageTiers': false,
                'fetchLiquidations': false,
                'fetchMarginMode': undefined,
                'fetchMarketLeverageTiers': false,
                'fetchMarkets': true,
                'fetchMarkOHLCV': false,
                'fetchMyLiquidations': false,
                'fetchMyTrades': true,
                'fetchOHLCV': true,
                'fetchOpenInterest': false,
                'fetchOpenInterestHistory': false,
                'fetchOpenInterests': false,
                'fetchOpenOrders': false,
                'fetchOrder': false,
                'fetchOrderBook': false,
                'fetchOrders': false,
                'fetchOrderTrades': false,
                'fetchPosition': false,
                'fetchPositionMode': false,
                'fetchPositions': false,
                'fetchPositionsRisk': false,
                'fetchPremiumIndexOHLCV': false,
                'fetchTicker': 'emulated',
                'fetchTickers': true,
                'fetchTime': false,
                'fetchTrades': false,
                'fetchTradingFee': false,
                'fetchTradingFees': false,
                'fetchTransfer': false,
                'fetchTransfers': false,
                'fetchWithdrawals': false,
                'repayCrossMargin': false,
                'repayIsolatedMargin': false,
                'setLeverage': false,
                'setMarginMode': false,
                'setPositionMode': false,
                'signIn': false,
                'transfer': false,
                'withdraw': false,
            },
            'timeframes': {
                '1m': '1',
                '1h': '60',
                '1d': '1D',
            },
            'urls': {
                'logo': 'https://elys.network/logo.png',
                'api': {
                    'public': 'https://testnet-elys-ccxt-service-j5trp.ondigitalocean.app',
                    'private': 'https://testnet-elys-ccxt-service-j5trp.ondigitalocean.app',
                },
                'test': {
                    'public': 'https://testnet-elys-ccxt-service-j5trp.ondigitalocean.app',
                    'private': 'https://testnet-elys-ccxt-service-j5trp.ondigitalocean.app',
                },
                'www': 'https://elys.network',
                'doc': [
                    'https://docs.elys.network',
                ],
                'fees': [
                    'https://docs.elys.network/developers/fees',
                ],
            },
            'api': {
                'public': {
                    'get': {
                        'v1/currencies': 1,
                        'v1/markets': 1,
                        'v1/tickers': 1,
                    },
                },
            },
            'fees': {
                'trading': {
                    'feeSide': 'get',
                    'tierBased': false,
                    'percentage': true,
                    'taker': this.parseNumber('0.001'),
                    'maker': this.parseNumber('0.001'), // 0.1%
                },
            },
            'precisionMode': TICK_SIZE,
            'exceptions': {
                'exact': {},
                'broad': {},
            },
            'options': {
                'sandboxMode': false,
                'defaultType': 'swap',
                'defaultSubType': 'linear', // 'linear', 'inverse'
            },
            'commonCurrencies': {},
        });
    }
    setSandboxMode(enabled) {
        super.setSandboxMode(enabled);
        this.options['sandboxMode'] = enabled;
    }
    /**
     * @method
     * @name elys#fetchCurrencies
     * @description fetches all available currencies on an exchange
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an associative dictionary of currencies
     */
    async fetchCurrencies(params = {}) {
        const url = this.urls['api']['public'] + '/v1/currencies';
        const response = await this.fetch(url, 'GET', undefined, undefined);
        //
        // [
        //     {
        //         "decimals": 6,
        //         "denom": "USDC"
        //     },
        //     {
        //         "decimals": 8,
        //         "denom": "WBTC"
        //     }
        // ]
        //
        const result = {};
        for (let i = 0; i < response.length; i++) {
            const currency = response[i];
            const id = this.safeString(currency, 'denom');
            const code = this.safeCurrencyCode(id);
            const decimals = this.safeInteger(currency, 'decimals');
            result[code] = this.safeCurrencyStructure({
                'id': id,
                'name': id,
                'code': code,
                'precision': decimals,
                'info': currency,
                'active': true,
                'deposit': undefined,
                'withdraw': undefined,
                'networks': undefined,
                'fee': undefined,
                'type': 'crypto',
                'limits': {
                    'amount': {
                        'min': undefined,
                        'max': undefined,
                    },
                    'withdraw': {
                        'min': undefined,
                        'max': undefined,
                    },
                },
            });
        }
        return result;
    }
    /**
     * @method
     * @name elys#fetchMarkets
     * @description retrieves data on all markets for elys
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    async fetchMarkets(params = {}) {
        const url = this.urls['api']['public'] + '/v1/markets';
        const response = await this.fetch(url, 'GET', undefined, undefined);
        //
        // {
        //     "amm_pools": [
        //         {
        //             "pool_assets": [
        //                 {
        //                     "token": {
        //                         "amount": "1000000",
        //                         "denom": "WBTC"
        //                     },
        //                     "weight": "50"
        //                 },
        //                 {
        //                     "token": {
        //                         "amount": "50000000000",
        //                         "denom": "USDC"
        //                     },
        //                     "weight": "50"
        //                 }
        //             ],
        //             "pool_id": 1,
        //             "pool_params": {
        //                 "fee_denom": "USDC",
        //                 "swap_fee": "0.003"
        //             }
        //         }
        //     ]
        // }
        //
        const result = [];
        const ammPools = this.safeList(response, 'amm_pools', []);
        for (let i = 0; i < ammPools.length; i++) {
            const pool = ammPools[i];
            const poolAssets = this.safeList(pool, 'pool_assets', []);
            if (poolAssets.length >= 2) {
                const baseAsset = poolAssets[0];
                const quoteAsset = poolAssets[1];
                const baseToken = this.safeDict(baseAsset, 'token', {});
                const quoteToken = this.safeDict(quoteAsset, 'token', {});
                const baseId = this.safeString(baseToken, 'denom');
                const quoteId = this.safeString(quoteToken, 'denom');
                const base = this.safeCurrencyCode(baseId);
                const quote = this.safeCurrencyCode(quoteId);
                const poolId = this.safeString(pool, 'pool_id');
                const symbol = base + '/' + quote;
                const poolParams = this.safeDict(pool, 'pool_params', {});
                const swapFee = this.safeString(poolParams, 'swap_fee');
                result.push(this.safeMarketStructure({
                    'id': poolId,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'settle': undefined,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'settleId': undefined,
                    'type': 'swap',
                    'spot': false,
                    'margin': false,
                    'swap': true,
                    'future': false,
                    'option': false,
                    'active': true,
                    'contract': true,
                    'linear': true,
                    'inverse': false,
                    'taker': this.parseNumber(swapFee),
                    'maker': this.parseNumber(swapFee),
                    'contractSize': undefined,
                    'expiry': undefined,
                    'expiryDatetime': undefined,
                    'strike': undefined,
                    'optionType': undefined,
                    'precision': {
                        'amount': undefined,
                        'price': undefined,
                    },
                    'limits': {
                        'leverage': {
                            'min': undefined,
                            'max': undefined,
                        },
                        'amount': {
                            'min': undefined,
                            'max': undefined,
                        },
                        'price': {
                            'min': undefined,
                            'max': undefined,
                        },
                        'cost': {
                            'min': undefined,
                            'max': undefined,
                        },
                    },
                    'created': undefined,
                    'info': pool,
                }));
            }
        }
        return result;
    }
    /**
     * @method
     * @name elys#fetchTickers
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of ticker structures
     */
    async fetchTickers(symbols = undefined, params = {}) {
        await this.loadMarkets();
        const request = {};
        if (symbols !== undefined) {
            const marketIds = [];
            for (let i = 0; i < symbols.length; i++) {
                const symbol = symbols[i];
                const market = this.market(symbol);
                marketIds.push(market['base'] + '-' + market['quote']);
            }
            request['symbols'] = marketIds;
        }
        const url = this.urls['api']['public'] + '/v1/tickers';
        const response = await this.fetch(url, 'GET', undefined, undefined);
        //
        // [
        //     {
        //         "instrument": "WBTC-USDC",
        //         "period24h": {
        //             "change": 1250.5,
        //             "changePercentage": 2.5,
        //             "high": 52000.0,
        //             "low": 49500.0,
        //             "open": 50000.0,
        //             "volume": 1500000.0
        //         },
        //         "price": 51250.5,
        //         "priceUsd": "51250.5",
        //         "timestamp": 1640995200000
        //     }
        // ]
        //
        const result = {};
        for (let i = 0; i < response.length; i++) {
            const ticker = this.parseTicker(response[i]);
            const symbol = ticker['symbol'];
            result[symbol] = ticker;
        }
        return this.filterByArrayTickers(result, 'symbol', symbols);
    }
    parseTicker(ticker, market = undefined) {
        //
        // {
        //     "instrument": "WBTC-USDC",
        //     "period24h": {
        //         "change": 1250.5,
        //         "changePercentage": 2.5,
        //         "high": 52000.0,
        //         "low": 49500.0,
        //         "open": 50000.0,
        //         "volume": 1500000.0
        //     },
        //     "price": 51250.5,
        //     "priceUsd": "51250.5",
        //     "timestamp": 1640995200000
        // }
        //
        const marketId = this.safeString(ticker, 'instrument');
        const symbol = this.safeSymbol(marketId, market, '-');
        const timestamp = this.safeInteger(ticker, 'timestamp');
        const period24h = this.safeDict(ticker, 'period24h', {});
        const last = this.safeString(ticker, 'price');
        const open = this.safeString(period24h, 'open');
        const high = this.safeString(period24h, 'high');
        const low = this.safeString(period24h, 'low');
        const change = this.safeString(period24h, 'change');
        const percentage = this.safeString(period24h, 'changePercentage');
        const baseVolume = this.safeString(period24h, 'volume');
        return this.safeTicker({
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601(timestamp),
            'high': high,
            'low': low,
            'bid': undefined,
            'bidVolume': undefined,
            'ask': undefined,
            'askVolume': undefined,
            'vwap': undefined,
            'open': open,
            'close': last,
            'last': last,
            'previousClose': undefined,
            'change': change,
            'percentage': percentage,
            'average': undefined,
            'baseVolume': baseVolume,
            'quoteVolume': undefined,
            'info': ticker,
        }, market);
    }
    /**
     * @method
     * @name elys#fetchOHLCV
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents, support '1m', '1h', '1d'
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest candle to fetch
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    async fetchOHLCV(symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets();
        const market = this.market(symbol);
        const until = this.safeInteger(params, 'until', this.milliseconds());
        let fromTime = since;
        if (fromTime === undefined) {
            if (limit !== undefined) {
                const timeframeInMilliseconds = this.parseTimeframe(timeframe) * 1000;
                fromTime = this.sum(until, timeframeInMilliseconds * limit * -1);
            }
            else {
                fromTime = 0;
            }
        }
        fromTime = Math.floor(fromTime / 1000); // convert to seconds
        const toTime = Math.floor(until / 1000); // convert to seconds
        params = this.omit(params, ['until']);
        const path = 'ohlcv/' + market['baseId'] + '/' + fromTime.toString() + '/' + toTime.toString() + '/' + this.safeString(this.timeframes, timeframe, timeframe);
        const url = this.urls['api']['public'] + '/' + path;
        const response = await this.fetch(url, 'GET', undefined, undefined);
        //
        // [
        //     {
        //         "close": 51000.0,
        //         "high": 51500.0,
        //         "low": 50500.0,
        //         "open": 50800.0,
        //         "timestamp": 1640995200
        //     }
        // ]
        //
        return this.parseOHLCVs(response, market, timeframe, since, limit);
    }
    parseOHLCV(ohlcv, market = undefined) {
        //
        // {
        //     "close": 51000.0,
        //     "high": 51500.0,
        //     "low": 50500.0,
        //     "open": 50800.0,
        //     "timestamp": 1640995200
        // }
        //
        return [
            this.safeTimestamp(ohlcv, 'timestamp'),
            this.safeNumber(ohlcv, 'open'),
            this.safeNumber(ohlcv, 'high'),
            this.safeNumber(ohlcv, 'low'),
            this.safeNumber(ohlcv, 'close'),
            undefined, // volume not provided in response
        ];
    }
    /**
     * @method
     * @name elys#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} params.address the wallet address to fetch balance for
     * @returns {object} a balance structure
     */
    async fetchBalance(params = {}) {
        const address = this.safeString(params, 'address');
        if (address === undefined) {
            throw new ArgumentsRequired(this.id + ' fetchBalance() requires an address parameter');
        }
        params = this.omit(params, ['address']);
        const path = 'v1/balance/' + address;
        const url = this.urls['api']['public'] + '/' + path;
        const response = await this.fetch(url, 'GET', undefined, undefined);
        //
        // {
        //     "leverage_lp_positions": [...],
        //     "liquid_assets": [
        //         {
        //             "amount": "1000000000",
        //             "denom": "USDC"
        //         },
        //         {
        //             "amount": "50000000",
        //             "denom": "WBTC"
        //         }
        //     ],
        //     "liquidity_positions": [...],
        //     "perpetual_positions": [...]
        // }
        //
        const result = {
            'info': response,
            'timestamp': undefined,
            'datetime': undefined,
        };
        const liquidAssets = this.safeList(response, 'liquid_assets', []);
        for (let i = 0; i < liquidAssets.length; i++) {
            const balance = liquidAssets[i];
            const currencyId = this.safeString(balance, 'denom');
            const code = this.safeCurrencyCode(currencyId);
            const amount = this.safeString(balance, 'amount');
            const account = this.account();
            account['free'] = amount;
            account['total'] = amount;
            result[code] = account;
        }
        return this.safeBalance(result);
    }
    /**
     * @method
     * @name elys#fetchMyTrades
     * @description fetch all trades made by the user
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} params.address the wallet address to fetch trades for
     * @param {int} [params.from] pagination offset, defaults to 0
     * @returns {Trade[]} a list of trade structures
     */
    async fetchMyTrades(symbol = undefined, since = undefined, limit = undefined, params = {}) {
        if (symbol === undefined) {
            throw new ArgumentsRequired(this.id + ' fetchMyTrades() requires a symbol parameter');
        }
        await this.loadMarkets();
        const market = this.market(symbol);
        const address = this.safeString(params, 'address');
        if (address === undefined) {
            throw new ArgumentsRequired(this.id + ' fetchMyTrades() requires an address parameter');
        }
        const fromParam = this.safeString(params, 'from', '0');
        const size = this.safeString(params, 'size', limit ? limit.toString() : '100');
        params = this.omit(params, ['address', 'from', 'size']);
        // Convert symbol to API format (base-quote)
        const symbolId = market['base'] + '-' + market['quote'];
        const path = 'trades/' + address + '/' + symbolId + '/' + size + '/' + fromParam;
        const url = this.urls['api']['public'] + '/' + path;
        const response = await this.fetch(url, 'GET', undefined, undefined);
        //
        // {
        //     "perpetual_position": [
        //         {
        //             "all_interests_paid": "string",
        //             "amm_pool_id": "string",
        //             "borrow_interest_paid_custody": "string",
        //             "closing_amount": "string",
        //             "closing_price": "string",
        //             "closing_ratio": "string",
        //             "collateral": "string",
        //             "collateral_amount": "string",
        //             "collateral_asset": "string",
        //             "created_at": "2019-08-24T14:15:22Z",
        //             "custody": "string",
        //             "custody_asset": "string",
        //             // ... more fields
        //             "txhash": "string",
        //             "type": "string"
        //         }
        //     ],
        //     "spot_orders": [
        //         {
        //             "amount": {
        //                 "amount": "string",
        //                 "denom": "string"
        //             },
        //             "created_at": "2019-08-24T14:15:22Z",
        //             "order_amount": {
        //                 "amount": "string",
        //                 "denom": "string"
        //             },
        //             "order_id": "string",
        //             "order_price": "string",
        //             "order_type": "string",
        //             "owner_address": "string",
        //             "spot_price": "string",
        //             "txhash": "string",
        //             "type": "string"
        //         }
        //     ]
        // }
        //
        const result = [];
        // Process perpetual position trades
        const perpetualPositions = this.safeList(response, 'perpetual_position', []);
        for (let i = 0; i < perpetualPositions.length; i++) {
            const trade = this.parseMyTrade(perpetualPositions[i], market);
            result.push(trade);
        }
        // Process spot order trades
        const spotOrders = this.safeList(response, 'spot_orders', []);
        for (let i = 0; i < spotOrders.length; i++) {
            const trade = this.parseMyTrade(spotOrders[i], market);
            result.push(trade);
        }
        return this.filterBySinceLimit(result, since, limit, 'timestamp');
    }
    parseMyTrade(trade, market = undefined) {
        //
        // Perpetual position trade:
        // {
        //     "all_interests_paid": "string",
        //     "amm_pool_id": "string",
        //     "closing_amount": "string",
        //     "closing_price": "string",
        //     "collateral_amount": "string",
        //     "created_at": "2019-08-24T14:15:22Z",
        //     "open_price": "string",
        //     "owner": "string",
        //     "position": "string",
        //     "txhash": "string",
        //     "type": "string"
        // }
        //
        // Spot order trade:
        // {
        //     "amount": {
        //         "amount": "string",
        //         "denom": "string"
        //     },
        //     "created_at": "2019-08-24T14:15:22Z",
        //     "order_amount": {
        //         "amount": "string",
        //         "denom": "string"
        //     },
        //     "order_id": "string",
        //     "order_price": "string",
        //     "order_type": "string",
        //     "owner_address": "string",
        //     "spot_price": "string",
        //     "txhash": "string",
        //     "type": "string"
        // }
        //
        const id = this.safeString2(trade, 'txhash', 'order_id');
        const timestamp = this.parse8601(this.safeString(trade, 'created_at'));
        const symbol = market ? market['symbol'] : undefined;
        // Determine if it's a perpetual or spot trade
        const isPerpetual = ('amm_pool_id' in trade);
        let amount;
        let price;
        let side;
        let type;
        if (isPerpetual) {
            // Perpetual position trade (can be open or closed)
            amount = this.safeString(trade, 'collateral'); // Use collateral as the position size
            price = this.safeString(trade, 'open_price'); // Use open_price for perpetual positions
            side = this.safeString(trade, 'position'); // 'long' or 'short'
            type = 'market'; // perpetual positions are typically market orders
        }
        else {
            // Spot order trade
            const orderAmount = this.safeDict(trade, 'order_amount', {});
            amount = this.safeString(orderAmount, 'amount');
            price = this.safeString2(trade, 'order_price', 'spot_price');
            const orderType = this.safeString(trade, 'order_type');
            side = (orderType === 'buy') ? 'buy' : 'sell';
            type = 'market'; // assuming market orders for now
        }
        const cost = (amount && price) ? this.numberToString(this.parseNumber(amount) * this.parseNumber(price)) : undefined;
        return this.safeTrade({
            'id': id,
            'order': this.safeString(trade, 'order_id'),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601(timestamp),
            'symbol': symbol,
            'type': type,
            'side': side,
            'amount': amount,
            'price': price,
            'cost': cost,
            'fee': undefined,
            'takerOrMaker': undefined,
        }, market);
    }
}
