<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\abstract\elys as Exchange;

class elys extends Exchange {

    public function describe(): mixed {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'elys',
            'name' => 'Elys Network',
            'countries' => array( 'US' ), // United States
            'version' => 'v1',
            'rateLimit' => 100, // 10 requests per second
            'certified' => false,
            'pro' => false,
            'dex' => true,
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => false,
                'swap' => true,
                'future' => true,
                'option' => false,
                'addMargin' => false,
                'borrowCrossMargin' => false,
                'borrowIsolatedMargin' => false,
                'cancelAllOrders' => false,
                'cancelAllOrdersAfter' => false,
                'cancelOrder' => false,
                'cancelOrders' => false,
                'cancelOrdersForSymbols' => false,
                'closeAllPositions' => false,
                'closePosition' => false,
                'createMarketBuyOrderWithCost' => false,
                'createMarketOrderWithCost' => false,
                'createMarketSellOrderWithCost' => false,
                'createOrder' => false,
                'createOrders' => false,
                'createOrderWithTakeProfitAndStopLoss' => false,
                'createReduceOnlyOrder' => false,
                'createStopOrder' => false,
                'createTriggerOrder' => false,
                'editOrder' => false,
                'editOrders' => false,
                'fetchAccounts' => false,
                'fetchBalance' => true,
                'fetchBorrowInterest' => false,
                'fetchBorrowRateHistories' => false,
                'fetchBorrowRateHistory' => false,
                'fetchCanceledAndClosedOrders' => false,
                'fetchCanceledOrders' => false,
                'fetchClosedOrders' => false,
                'fetchCrossBorrowRate' => false,
                'fetchCrossBorrowRates' => false,
                'fetchCurrencies' => true,
                'fetchDepositAddress' => false,
                'fetchDepositAddresses' => false,
                'fetchDeposits' => false,
                'fetchDepositWithdrawFee' => false,
                'fetchDepositWithdrawFees' => false,
                'fetchFundingHistory' => false,
                'fetchFundingRate' => false,
                'fetchFundingRateHistory' => false,
                'fetchFundingRates' => false,
                'fetchIndexOHLCV' => false,
                'fetchIsolatedBorrowRate' => false,
                'fetchIsolatedBorrowRates' => false,
                'fetchLedger' => false,
                'fetchLeverage' => false,
                'fetchLeverageTiers' => false,
                'fetchLiquidations' => false,
                'fetchMarginMode' => null,
                'fetchMarketLeverageTiers' => false,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => false,
                'fetchMyLiquidations' => false,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenInterest' => false,
                'fetchOpenInterestHistory' => false,
                'fetchOpenInterests' => false,
                'fetchOpenOrders' => false,
                'fetchOrder' => false,
                'fetchOrderBook' => false,
                'fetchOrders' => false,
                'fetchOrderTrades' => false,
                'fetchPosition' => false,
                'fetchPositionMode' => false,
                'fetchPositions' => false,
                'fetchPositionsRisk' => false,
                'fetchPremiumIndexOHLCV' => false,
                'fetchTicker' => 'emulated',
                'fetchTickers' => true,
                'fetchTime' => false,
                'fetchTrades' => false,
                'fetchTradingFee' => false,
                'fetchTradingFees' => false,
                'fetchTransfer' => false,
                'fetchTransfers' => false,
                'fetchWithdrawals' => false,
                'repayCrossMargin' => false,
                'repayIsolatedMargin' => false,
                'setLeverage' => false,
                'setMarginMode' => false,
                'setPositionMode' => false,
                'signIn' => false,
                'transfer' => false,
                'withdraw' => false,
            ),
            'timeframes' => array(
                '1m' => '1',
                '1h' => '60',
                '1d' => '1D',
            ),
            'urls' => array(
                'logo' => 'https://elys.network/logo.png',
                'api' => array(
                    'public' => 'https://testnet-elys-ccxt-service-j5trp.ondigitalocean.app',
                    'private' => 'https://testnet-elys-ccxt-service-j5trp.ondigitalocean.app',
                ),
                'test' => array(
                    'public' => 'https://testnet-elys-ccxt-service-j5trp.ondigitalocean.app',
                    'private' => 'https://testnet-elys-ccxt-service-j5trp.ondigitalocean.app',
                ),
                'www' => 'https://elys.network',
                'doc' => array(
                    'https://docs.elys.network',
                ),
                'fees' => array(
                    'https://docs.elys.network/developers/fees',
                ),
            ),
            'api' => array(
                'public' => array(
                    'get' => array(
                        'v1/currencies' => 1,
                        'v1/markets' => 1,
                        'v1/tickers' => 1,
                    ),
                ),
            ),
            'fees' => array(
                'trading' => array(
                    'feeSide' => 'get',
                    'tierBased' => false,
                    'percentage' => true,
                    'taker' => $this->parse_number('0.001'), // 0.1%
                    'maker' => $this->parse_number('0.001'), // 0.1%
                ),
            ),
            'precisionMode' => TICK_SIZE,
            'exceptions' => array(
                'exact' => array(),
                'broad' => array(),
            ),
            'options' => array(
                'sandboxMode' => false,
                'defaultType' => 'swap', // 'spot', 'swap'
                'defaultSubType' => 'linear', // 'linear', 'inverse'
            ),
            'commonCurrencies' => array(),
        ));
    }

    public function set_sandbox_mode($enabled) {
        parent::set_sandbox_mode($enabled);
        $this->options['sandboxMode'] = $enabled;
    }

    public function fetch_currencies($params = array ()): ?array {
        /**
         * fetches all available currencies on an exchange
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} an associative dictionary of currencies
         */
        $url = $this->urls['api']['public'] . '/v1/currencies';
        $response = $this->fetch($url, 'GET', null, null);
        //
        // array(
        //     array(
        //         "decimals" => 6,
        //         "denom" => "USDC"
        //     ),
        //     {
        //         "decimals" => 8,
        //         "denom" => "WBTC"
        //     }
        // )
        //
        $result = array();
        for ($i = 0; $i < count($response); $i++) {
            $currency = $response[$i];
            $id = $this->safe_string($currency, 'denom');
            $code = $this->safe_currency_code($id);
            $decimals = $this->safe_integer($currency, 'decimals');
            $result[$code] = $this->safe_currency_structure(array(
                'id' => $id,
                'name' => $id,
                'code' => $code,
                'precision' => $decimals,
                'info' => $currency,
                'active' => true,
                'deposit' => null,
                'withdraw' => null,
                'networks' => null,
                'fee' => null,
                'type' => 'crypto',
                'limits' => array(
                    'amount' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'withdraw' => array(
                        'min' => null,
                        'max' => null,
                    ),
                ),
            ));
        }
        return $result;
    }

    public function fetch_markets($params = array ()): array {
        /**
         * retrieves data on all markets for elys
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array[]} an array of objects representing market data
         */
        $url = $this->urls['api']['public'] . '/v1/markets';
        $response = $this->fetch($url, 'GET', null, null);
        //
        // {
        //     "amm_pools" => array(
        //         {
        //             "pool_assets" => array(
        //                 array(
        //                     "token" => array(
        //                         "amount" => "1000000",
        //                         "denom" => "WBTC"
        //                     ),
        //                     "weight" => "50"
        //                 ),
        //                 {
        //                     "token" => array(
        //                         "amount" => "50000000000",
        //                         "denom" => "USDC"
        //                     ),
        //                     "weight" => "50"
        //                 }
        //             ),
        //             "pool_id" => 1,
        //             "pool_params" => {
        //                 "fee_denom" => "USDC",
        //                 "swap_fee" => "0.003"
        //             }
        //         }
        //     )
        // }
        //
        $result = array();
        $ammPools = $this->safe_list($response, 'amm_pools', array());
        for ($i = 0; $i < count($ammPools); $i++) {
            $pool = $ammPools[$i];
            $poolAssets = $this->safe_list($pool, 'pool_assets', array());
            if (strlen($poolAssets) >= 2) {
                $baseAsset = $poolAssets[0];
                $quoteAsset = $poolAssets[1];
                $baseToken = $this->safe_dict($baseAsset, 'token', array());
                $quoteToken = $this->safe_dict($quoteAsset, 'token', array());
                $baseId = $this->safe_string($baseToken, 'denom');
                $quoteId = $this->safe_string($quoteToken, 'denom');
                $base = $this->safe_currency_code($baseId);
                $quote = $this->safe_currency_code($quoteId);
                $poolId = $this->safe_string($pool, 'pool_id');
                $symbol = $base . '/' . $quote;
                $poolParams = $this->safe_dict($pool, 'pool_params', array());
                $swapFee = $this->safe_string($poolParams, 'swap_fee');
                $result[] = $this->safe_market_structure(array(
                    'id' => $poolId,
                    'symbol' => $symbol,
                    'base' => $base,
                    'quote' => $quote,
                    'settle' => null,
                    'baseId' => $baseId,
                    'quoteId' => $quoteId,
                    'settleId' => null,
                    'type' => 'swap',
                    'spot' => false,
                    'margin' => false,
                    'swap' => true,
                    'future' => false,
                    'option' => false,
                    'active' => true,
                    'contract' => true,
                    'linear' => true,
                    'inverse' => false,
                    'taker' => $this->parse_number($swapFee),
                    'maker' => $this->parse_number($swapFee),
                    'contractSize' => null,
                    'expiry' => null,
                    'expiryDatetime' => null,
                    'strike' => null,
                    'optionType' => null,
                    'precision' => array(
                        'amount' => null,
                        'price' => null,
                    ),
                    'limits' => array(
                        'leverage' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'amount' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'price' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'cost' => array(
                            'min' => null,
                            'max' => null,
                        ),
                    ),
                    'created' => null,
                    'info' => $pool,
                ));
            }
        }
        return $result;
    }

    public function fetch_tickers(?array $symbols = null, $params = array ()): array {
        /**
         * fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each $market
         * @param {string[]|null} $symbols unified $symbols of the markets to fetch the $ticker for, all $market tickers are returned if not assigned
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a dictionary of $ticker structures
         */
        $this->load_markets();
        $request = array();
        if ($symbols !== null) {
            $marketIds = array();
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $market = $this->market($symbol);
                $marketIds[] = $market['base'] . '-' . $market['quote'];
            }
            $request['symbols'] = $marketIds;
        }
        $url = $this->urls['api']['public'] . '/v1/tickers';
        $response = $this->fetch($url, 'GET', null, null);
        //
        // array(
        //     {
        //         "instrument" => "WBTC-USDC",
        //         "period24h" => array(
        //             "change" => 1250.5,
        //             "changePercentage" => 2.5,
        //             "high" => 52000.0,
        //             "low" => 49500.0,
        //             "open" => 50000.0,
        //             "volume" => 1500000.0
        //         ),
        //         "price" => 51250.5,
        //         "priceUsd" => "51250.5",
        //         "timestamp" => 1640995200000
        //     }
        // )
        //
        $result = array();
        for ($i = 0; $i < count($response); $i++) {
            $ticker = $this->parse_ticker($response[$i]);
            $symbol = $ticker['symbol'];
            $result[$symbol] = $ticker;
        }
        return $this->filter_by_array_tickers($result, 'symbol', $symbols);
    }

    public function parse_ticker($ticker, ?array $market = null): array {
        //
        // {
        //     "instrument" => "WBTC-USDC",
        //     "period24h" => array(
        //         "change" => 1250.5,
        //         "changePercentage" => 2.5,
        //         "high" => 52000.0,
        //         "low" => 49500.0,
        //         "open" => 50000.0,
        //         "volume" => 1500000.0
        //     ),
        //     "price" => 51250.5,
        //     "priceUsd" => "51250.5",
        //     "timestamp" => 1640995200000
        // }
        //
        $marketId = $this->safe_string($ticker, 'instrument');
        $symbol = $this->safe_symbol($marketId, $market, '-');
        $timestamp = $this->safe_integer($ticker, 'timestamp');
        $period24h = $this->safe_dict($ticker, 'period24h', array());
        $last = $this->safe_string($ticker, 'price');
        $open = $this->safe_string($period24h, 'open');
        $high = $this->safe_string($period24h, 'high');
        $low = $this->safe_string($period24h, 'low');
        $change = $this->safe_string($period24h, 'change');
        $percentage = $this->safe_string($period24h, 'changePercentage');
        $baseVolume = $this->safe_string($period24h, 'volume');
        return $this->safe_ticker(array(
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $high,
            'low' => $low,
            'bid' => null,
            'bidVolume' => null,
            'ask' => null,
            'askVolume' => null,
            'vwap' => null,
            'open' => $open,
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => $change,
            'percentage' => $percentage,
            'average' => null,
            'baseVolume' => $baseVolume,
            'quoteVolume' => null,
            'info' => $ticker,
        ), $market);
    }

    public function fetch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
         * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
         * @param {string} $timeframe the length of time each candle represents, support '1m', '1h', '1d'
         * @param {int} [$since] timestamp in ms of the earliest candle to fetch
         * @param {int} [$limit] the maximum amount of candles to fetch
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {int} [$params->until] timestamp in ms of the latest candle to fetch
         * @return {int[][]} A list of candles ordered, open, high, low, close, volume
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $until = $this->safe_integer($params, 'until', $this->milliseconds());
        $fromTime = $since;
        if ($fromTime === null) {
            if ($limit !== null) {
                $timeframeInMilliseconds = $this->parse_timeframe($timeframe) * 1000;
                $fromTime = $this->sum($until, $timeframeInMilliseconds * $limit * -1);
            } else {
                $fromTime = 0;
            }
        }
        $fromTime = (int) floor($fromTime / 1000); // convert to seconds
        $toTime = (int) floor($until / 1000); // convert to seconds
        $params = $this->omit($params, array( 'until' ));
        $path = 'ohlcv/' . $market['baseId'] . '/' . (string) $fromTime . '/' . (string) $toTime . '/' . $this->safe_string($this->timeframes, $timeframe, $timeframe);
        $url = $this->urls['api']['public'] . '/' . $path;
        $response = $this->fetch($url, 'GET', null, null);
        //
        // array(
        //     {
        //         "close" => 51000.0,
        //         "high" => 51500.0,
        //         "low" => 50500.0,
        //         "open" => 50800.0,
        //         "timestamp" => 1640995200
        //     }
        // )
        //
        return $this->parse_ohlcvs($response, $market, $timeframe, $since, $limit);
    }

    public function parse_ohlcv($ohlcv, ?array $market = null): array {
        //
        // {
        //     "close" => 51000.0,
        //     "high" => 51500.0,
        //     "low" => 50500.0,
        //     "open" => 50800.0,
        //     "timestamp" => 1640995200
        // }
        //
        return array(
            $this->safe_timestamp($ohlcv, 'timestamp'),
            $this->safe_number($ohlcv, 'open'),
            $this->safe_number($ohlcv, 'high'),
            $this->safe_number($ohlcv, 'low'),
            $this->safe_number($ohlcv, 'close'),
            null, // volume not provided in response
        );
    }

    public function fetch_balance($params = array ()): array {
        /**
         * query for $balance and get the $amount of funds available for trading or funds locked in orders
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} $params->address the wallet $address to fetch $balance for
         * @return {array} a $balance structure
         */
        $address = $this->safe_string($params, 'address');
        if ($address === null) {
            throw new ArgumentsRequired($this->id . ' fetchBalance() requires an $address parameter');
        }
        $params = $this->omit($params, array( 'address' ));
        $path = 'v1/balance/' . $address;
        $url = $this->urls['api']['public'] . '/' . $path;
        $response = $this->fetch($url, 'GET', null, null);
        //
        // {
        //     "leverage_lp_positions" => [...],
        //     "liquid_assets" => array(
        //         array(
        //             "amount" => "1000000000",
        //             "denom" => "USDC"
        //         ),
        //         {
        //             "amount" => "50000000",
        //             "denom" => "WBTC"
        //         }
        //     ),
        //     "liquidity_positions" => [...],
        //     "perpetual_positions" => [...]
        // }
        //
        $result = array(
            'info' => $response,
            'timestamp' => null,
            'datetime' => null,
        );
        $liquidAssets = $this->safe_list($response, 'liquid_assets', array());
        for ($i = 0; $i < count($liquidAssets); $i++) {
            $balance = $liquidAssets[$i];
            $currencyId = $this->safe_string($balance, 'denom');
            $code = $this->safe_currency_code($currencyId);
            $amount = $this->safe_string($balance, 'amount');
            $account = $this->account();
            $account['free'] = $amount;
            $account['total'] = $amount;
            $result[$code] = $account;
        }
        return $this->safe_balance($result);
    }

    public function fetch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetch all trades made by the user
         * @param {string} $symbol unified $market $symbol
         * @param {int} [$since] the earliest time in ms to fetch trades for
         * @param {int} [$limit] the maximum number of trades structures to retrieve
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} $params->address the wallet $address to fetch trades for
         * @param {int} [$params->from] pagination offset, defaults to 0
         * @return {Trade[]} a list of $trade structures
         */
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchMyTrades() requires a $symbol parameter');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $address = $this->safe_string($params, 'address');
        if ($address === null) {
            throw new ArgumentsRequired($this->id . ' fetchMyTrades() requires an $address parameter');
        }
        $fromParam = $this->safe_string($params, 'from', '0');
        $size = $this->safe_string($params, 'size', $limit ? (string) $limit : '100');
        $params = $this->omit($params, array( 'address', 'from', 'size' ));
        // Convert $symbol to API format (base-quote)
        $symbolId = $market['base'] . '-' . $market['quote'];
        $path = 'trades/' . $address . '/' . $symbolId . '/' . $size . '/' . $fromParam;
        $url = $this->urls['api']['public'] . '/' . $path;
        $response = $this->fetch($url, 'GET', null, null);
        //
        // {
        //     "perpetual_position" => array(
        //         {
        //             "all_interests_paid" => "string",
        //             "amm_pool_id" => "string",
        //             "borrow_interest_paid_custody" => "string",
        //             "closing_amount" => "string",
        //             "closing_price" => "string",
        //             "closing_ratio" => "string",
        //             "collateral" => "string",
        //             "collateral_amount" => "string",
        //             "collateral_asset" => "string",
        //             "created_at" => "2019-08-24T14:15:22Z",
        //             "custody" => "string",
        //             "custody_asset" => "string",
        //             // ... more fields
        //             "txhash" => "string",
        //             "type" => "string"
        //         }
        //     ),
        //     "spot_orders" => array(
        //         {
        //             "amount" => array(
        //                 "amount" => "string",
        //                 "denom" => "string"
        //             ),
        //             "created_at" => "2019-08-24T14:15:22Z",
        //             "order_amount" => array(
        //                 "amount" => "string",
        //                 "denom" => "string"
        //             ),
        //             "order_id" => "string",
        //             "order_price" => "string",
        //             "order_type" => "string",
        //             "owner_address" => "string",
        //             "spot_price" => "string",
        //             "txhash" => "string",
        //             "type" => "string"
        //         }
        //     )
        // }
        //
        $result = array();
        // Process perpetual position trades
        $perpetualPositions = $this->safe_list($response, 'perpetual_position', array());
        for ($i = 0; $i < count($perpetualPositions); $i++) {
            $trade = $this->parse_my_trade($perpetualPositions[$i], $market);
            $result[] = $trade;
        }
        // Process spot order trades
        $spotOrders = $this->safe_list($response, 'spot_orders', array());
        for ($i = 0; $i < count($spotOrders); $i++) {
            $trade = $this->parse_my_trade($spotOrders[$i], $market);
            $result[] = $trade;
        }
        return $this->filter_by_since_limit($result, $since, $limit, 'timestamp');
    }

    public function parse_my_trade($trade, ?array $market = null): array {
        //
        // Perpetual position $trade:
        // {
        //     "all_interests_paid" => "string",
        //     "amm_pool_id" => "string",
        //     "closing_amount" => "string",
        //     "closing_price" => "string",
        //     "collateral_amount" => "string",
        //     "created_at" => "2019-08-24T14:15:22Z",
        //     "open_price" => "string",
        //     "owner" => "string",
        //     "position" => "string",
        //     "txhash" => "string",
        //     "type" => "string"
        // }
        //
        // Spot order $trade:
        // {
        //     "amount" => array(
        //         "amount" => "string",
        //         "denom" => "string"
        //     ),
        //     "created_at" => "2019-08-24T14:15:22Z",
        //     "order_amount" => array(
        //         "amount" => "string",
        //         "denom" => "string"
        //     ),
        //     "order_id" => "string",
        //     "order_price" => "string",
        //     "order_type" => "string",
        //     "owner_address" => "string",
        //     "spot_price" => "string",
        //     "txhash" => "string",
        //     "type" => "string"
        // }
        //
        $id = $this->safe_string_2($trade, 'txhash', 'order_id');
        $timestamp = $this->parse8601($this->safe_string($trade, 'created_at'));
        $symbol = $market ? $market['symbol'] : null;
        // Determine if it's a perpetual or spot $trade
        $isPerpetual = (is_array($trade) && array_key_exists('amm_pool_id', $trade));
        if ($isPerpetual) {
            // Perpetual position $trade (can be open or closed)
            $amount = $this->safe_string($trade, 'collateral'); // Use collateral position size
            $price = $this->safe_string($trade, 'open_price'); // Use open_price for perpetual positions
            $side = $this->safe_string($trade, 'position'); // 'long' or 'short'
            $type = 'market'; // perpetual positions are typically $market orders
        } else {
            // Spot order $trade
            $orderAmount = $this->safe_dict($trade, 'order_amount', array());
            $amount = $this->safe_string($orderAmount, 'amount');
            $price = $this->safe_string_2($trade, 'order_price', 'spot_price');
            $orderType = $this->safe_string($trade, 'order_type');
            $side = ($orderType === 'buy') ? 'buy' : 'sell';
            $type = 'market'; // assuming $market orders for now
        }
        $cost = ($amount && $price) ? $this->number_to_string($this->parse_number($amount) * $this->parse_number($price)) : null;
        return $this->safe_trade(array(
            'id' => $id,
            'order' => $this->safe_string($trade, 'order_id'),
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'type' => $type,
            'side' => $side,
            'amount' => $amount,
            'price' => $price,
            'cost' => $cost,
            'fee' => null, // fee information not directly available
            'takerOrMaker' => null,
        ), $market);
    }
}
