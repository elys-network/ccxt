<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\abstract\elys as Exchange;

class elys extends Exchange {

    public function describe(): mixed {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'elys',
            'name' => 'Elys Network',
            'countries' => array( 'US' ), // United States
            'version' => 'v1',
            'rateLimit' => 100, // 10 requests per second
            'certified' => false,
            'pro' => false,
            'dex' => true,
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => false,
                'swap' => true,
                'future' => true,
                'option' => false,
                'addMargin' => false,
                'borrowCrossMargin' => false,
                'borrowIsolatedMargin' => false,
                'cancelAllOrders' => false,
                'cancelAllOrdersAfter' => false,
                'cancelOrder' => false,
                'cancelOrders' => false,
                'cancelOrdersForSymbols' => false,
                'closeAllPositions' => false,
                'closePosition' => false,
                'createMarketBuyOrderWithCost' => false,
                'createMarketOrderWithCost' => false,
                'createMarketSellOrderWithCost' => false,
                'createOrder' => false,
                'createOrders' => false,
                'createOrderWithTakeProfitAndStopLoss' => false,
                'createReduceOnlyOrder' => false,
                'createStopOrder' => false,
                'createTriggerOrder' => false,
                'editOrder' => false,
                'editOrders' => false,
                'fetchAccounts' => false,
                'fetchBalance' => true,
                'fetchBorrowInterest' => false,
                'fetchBorrowRateHistories' => false,
                'fetchBorrowRateHistory' => false,
                'fetchCanceledAndClosedOrders' => false,
                'fetchCanceledOrders' => false,
                'fetchClosedOrders' => false,
                'fetchCrossBorrowRate' => false,
                'fetchCrossBorrowRates' => false,
                'fetchCurrencies' => true,
                'fetchDepositAddress' => false,
                'fetchDepositAddresses' => false,
                'fetchDeposits' => false,
                'fetchDepositWithdrawFee' => false,
                'fetchDepositWithdrawFees' => false,
                'fetchFundingHistory' => false,
                'fetchFundingRate' => false,
                'fetchFundingRateHistory' => false,
                'fetchFundingRates' => true,
                'fetchIndexOHLCV' => false,
                'fetchIsolatedBorrowRate' => false,
                'fetchIsolatedBorrowRates' => false,
                'fetchLedger' => false,
                'fetchLeverage' => false,
                'fetchLeverageTiers' => false,
                'fetchLiquidations' => false,
                'fetchMarginMode' => null,
                'fetchMarketLeverageTiers' => false,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => false,
                'fetchMyLiquidations' => false,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenInterest' => true,
                'fetchOpenInterestHistory' => false,
                'fetchOpenInterests' => false,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => false,
                'fetchOrders' => true,
                'fetchOrderTrades' => false,
                'fetchPosition' => false,
                'fetchPositionMode' => false,
                'fetchPositions' => false,
                'fetchPositionsRisk' => false,
                'fetchPremiumIndexOHLCV' => false,
                'fetchTicker' => 'emulated',
                'fetchTickers' => true,
                'fetchTime' => false,
                'fetchTrades' => true,
                'fetchTradingFee' => false,
                'fetchTradingFees' => false,
                'fetchTransfer' => false,
                'fetchTransfers' => false,
                'fetchWithdrawals' => false,
                'repayCrossMargin' => false,
                'repayIsolatedMargin' => false,
                'setLeverage' => false,
                'setMarginMode' => false,
                'setPositionMode' => false,
                'signIn' => false,
                'transfer' => false,
                'withdraw' => false,
            ),
            'timeframes' => array(
                '1m' => '1',
                '1h' => '60',
                '1d' => '1D',
            ),
            'urls' => array(
                'logo' => 'https://elys.network/logo.png',
                'api' => array(
                    'public' => 'https://testnet-elys-ccxt-service-j5trp.ondigitalocean.app',
                    'private' => 'https://testnet-elys-ccxt-service-j5trp.ondigitalocean.app',
                ),
                'test' => array(
                    'public' => 'https://testnet-elys-ccxt-service-j5trp.ondigitalocean.app',
                    'private' => 'https://testnet-elys-ccxt-service-j5trp.ondigitalocean.app',
                ),
                'www' => 'https://elys.network',
                'doc' => array(
                    'https://docs.elys.network',
                ),
                'fees' => array(
                    'https://docs.elys.network/developers/fees',
                ),
            ),
            'api' => array(
                'public' => array(
                    'get' => array(
                        'v1/currencies' => 1,
                        'v1/markets' => 1,
                        'v1/tickers' => 1,
                        'v1/funding-rates' => 1,
                        'v1/orders/open' => 1,
                        'v1/orders' => 1,
                        'v1/order' => 1,
                        'v1/open-interest' => 1,
                        'trades/{address}/{symbol}/{size}/{from}' => 1,
                    ),
                ),
            ),
            'fees' => array(
                'trading' => array(
                    'feeSide' => 'get',
                    'tierBased' => false,
                    'percentage' => true,
                    'taker' => $this->parse_number('0.001'), // 0.1%
                    'maker' => $this->parse_number('0.001'), // 0.1%
                ),
            ),
            'precisionMode' => TICK_SIZE,
            'exceptions' => array(
                'exact' => array(),
                'broad' => array(),
            ),
            'options' => array(
                'sandboxMode' => false,
                'defaultType' => 'swap', // 'spot', 'swap'
                'defaultSubType' => 'linear', // 'linear', 'inverse'
            ),
            'commonCurrencies' => array(),
        ));
    }

    public function set_sandbox_mode($enabled) {
        parent::set_sandbox_mode($enabled);
        $this->options['sandboxMode'] = $enabled;
    }

    public function fetch_currencies($params = array ()): ?array {
        /**
         * fetches all available currencies on an exchange
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} an associative dictionary of currencies
         */
        $url = $this->urls['api']['public'] . '/v1/currencies';
        $response = $this->fetch($url, 'GET', null, null);
        //
        // array(
        //     array(
        //         "decimals" => 6,
        //         "denom" => "USDC"
        //     ),
        //     {
        //         "decimals" => 8,
        //         "denom" => "WBTC"
        //     }
        // )
        //
        $result = array();
        for ($i = 0; $i < count($response); $i++) {
            $currency = $response[$i];
            $id = $this->safe_string($currency, 'denom');
            $code = $this->safe_currency_code($id);
            $decimals = $this->safe_integer($currency, 'decimals');
            $result[$code] = $this->safe_currency_structure(array(
                'id' => $id,
                'name' => $id,
                'code' => $code,
                'precision' => $decimals,
                'info' => $currency,
                'active' => true,
                'deposit' => null,
                'withdraw' => null,
                'networks' => null,
                'fee' => null,
                'type' => 'crypto',
                'limits' => array(
                    'amount' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'withdraw' => array(
                        'min' => null,
                        'max' => null,
                    ),
                ),
            ));
        }
        return $result;
    }

    public function fetch_markets($params = array ()): array {
        /**
         * retrieves data on all markets for elys
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array[]} an array of objects representing market data
         */
        $url = $this->urls['api']['public'] . '/v1/markets';
        $response = $this->fetch($url, 'GET', null, null);
        //
        // {
        //     "amm_pools" => array(
        //         {
        //             "pool_assets" => array(
        //                 array(
        //                     "token" => array(
        //                         "amount" => "1000000",
        //                         "denom" => "WBTC"
        //                     ),
        //                     "weight" => "50"
        //                 ),
        //                 {
        //                     "token" => array(
        //                         "amount" => "50000000000",
        //                         "denom" => "USDC"
        //                     ),
        //                     "weight" => "50"
        //                 }
        //             ),
        //             "pool_id" => 1,
        //             "pool_params" => {
        //                 "fee_denom" => "USDC",
        //                 "swap_fee" => "0.003"
        //             }
        //         }
        //     )
        // }
        //
        $result = array();
        $ammPools = $this->safe_list($response, 'amm_pools', array());
        for ($i = 0; $i < count($ammPools); $i++) {
            $pool = $ammPools[$i];
            $poolAssets = $this->safe_list($pool, 'pool_assets', array());
            if (strlen($poolAssets) >= 2) {
                $baseAsset = $poolAssets[0];
                $quoteAsset = $poolAssets[1];
                $baseToken = $this->safe_dict($baseAsset, 'token', array());
                $quoteToken = $this->safe_dict($quoteAsset, 'token', array());
                $baseId = $this->safe_string($baseToken, 'denom');
                $quoteId = $this->safe_string($quoteToken, 'denom');
                $base = $this->safe_currency_code($baseId);
                $quote = $this->safe_currency_code($quoteId);
                $poolId = $this->safe_string($pool, 'pool_id');
                $symbol = $base . '/' . $quote;
                $poolParams = $this->safe_dict($pool, 'pool_params', array());
                $swapFee = $this->safe_string($poolParams, 'swap_fee');
                $result[] = $this->safe_market_structure(array(
                    'id' => $poolId,
                    'symbol' => $symbol,
                    'base' => $base,
                    'quote' => $quote,
                    'settle' => null,
                    'baseId' => $baseId,
                    'quoteId' => $quoteId,
                    'settleId' => null,
                    'type' => 'swap',
                    'spot' => false,
                    'margin' => false,
                    'swap' => true,
                    'future' => false,
                    'option' => false,
                    'active' => true,
                    'contract' => true,
                    'linear' => true,
                    'inverse' => false,
                    'taker' => $this->parse_number($swapFee),
                    'maker' => $this->parse_number($swapFee),
                    'contractSize' => null,
                    'expiry' => null,
                    'expiryDatetime' => null,
                    'strike' => null,
                    'optionType' => null,
                    'precision' => array(
                        'amount' => null,
                        'price' => null,
                    ),
                    'limits' => array(
                        'leverage' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'amount' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'price' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'cost' => array(
                            'min' => null,
                            'max' => null,
                        ),
                    ),
                    'created' => null,
                    'info' => $pool,
                ));
            }
        }
        return $result;
    }

    public function fetch_tickers(?array $symbols = null, $params = array ()): array {
        /**
         * fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each $market
         * @param {string[]|null} $symbols unified $symbols of the markets to fetch the $ticker for, all $market tickers are returned if not assigned
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a dictionary of $ticker structures
         */
        $this->load_markets();
        $request = array();
        if ($symbols !== null) {
            $marketIds = array();
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $market = $this->market($symbol);
                $marketIds[] = $market['base'] . '-' . $market['quote'];
            }
            $request['symbols'] = $marketIds;
        }
        $url = $this->urls['api']['public'] . '/v1/tickers';
        $response = $this->fetch($url, 'GET', null, null);
        //
        // array(
        //     {
        //         "instrument" => "WBTC-USDC",
        //         "period24h" => array(
        //             "change" => 1250.5,
        //             "changePercentage" => 2.5,
        //             "high" => 52000.0,
        //             "low" => 49500.0,
        //             "open" => 50000.0,
        //             "volume" => 1500000.0
        //         ),
        //         "price" => 51250.5,
        //         "priceUsd" => "51250.5",
        //         "timestamp" => 1640995200000
        //     }
        // )
        //
        $result = array();
        for ($i = 0; $i < count($response); $i++) {
            $ticker = $this->parse_ticker($response[$i]);
            $symbol = $ticker['symbol'];
            $result[$symbol] = $ticker;
        }
        return $this->filter_by_array_tickers($result, 'symbol', $symbols);
    }

    public function parse_ticker($ticker, ?array $market = null): array {
        //
        // {
        //     "instrument" => "WBTC-USDC",
        //     "period24h" => array(
        //         "change" => 1250.5,
        //         "changePercentage" => 2.5,
        //         "high" => 52000.0,
        //         "low" => 49500.0,
        //         "open" => 50000.0,
        //         "volume" => 1500000.0
        //     ),
        //     "price" => 51250.5,
        //     "priceUsd" => "51250.5",
        //     "timestamp" => 1640995200000
        // }
        //
        $marketId = $this->safe_string($ticker, 'instrument');
        $symbol = $this->safe_symbol($marketId, $market, '-');
        $timestamp = $this->safe_integer($ticker, 'timestamp');
        $period24h = $this->safe_dict($ticker, 'period24h', array());
        $last = $this->safe_string($ticker, 'price');
        $open = $this->safe_string($period24h, 'open');
        $high = $this->safe_string($period24h, 'high');
        $low = $this->safe_string($period24h, 'low');
        $change = $this->safe_string($period24h, 'change');
        $percentage = $this->safe_string($period24h, 'changePercentage');
        $baseVolume = $this->safe_string($period24h, 'volume');
        return $this->safe_ticker(array(
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $high,
            'low' => $low,
            'bid' => null,
            'bidVolume' => null,
            'ask' => null,
            'askVolume' => null,
            'vwap' => null,
            'open' => $open,
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => $change,
            'percentage' => $percentage,
            'average' => null,
            'baseVolume' => $baseVolume,
            'quoteVolume' => null,
            'info' => $ticker,
        ), $market);
    }

    public function fetch_funding_rates(?array $symbols = null, $params = array ()): array {
        /**
         * fetch the funding rates for multiple markets
         * @param {string[]|null} $symbols unified $symbols of the markets to fetch the funding rates for, all market funding rates are returned if not assigned
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a dictionary of funding rates structures
         */
        $this->load_markets();
        $url = $this->urls['api']['public'] . '/v1/funding-rates';
        $response = $this->fetch($url, 'GET', null, null);
        //
        // array(
        //   {
        //     "symbol" => "ATOM-USDC",
        //     "funding_rate" => "-0.117462885648393966",
        //     "long_rate" => "-0.189599831252923122",
        //     "short_rate" => "0.117462885648393966",
        //     "timestamp" => 1754361530209
        //   }
        // )
        //
        $result = array();
        for ($i = 0; $i < count($response); $i++) {
            $fundingRate = $this->parse_funding_rate($response[$i]);
            $symbol = $fundingRate['symbol'];
            $result[$symbol] = $fundingRate;
        }
        return $this->filter_by_array($result, 'symbol', $symbols);
    }

    public function fetch_open_interest(string $symbol, $params = array ()): OpenInterest {
        /**
         * fetch the open interest for a $symbol
         * @param {string} $symbol unified $market $symbol
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} an open interest structure
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $query = array(
            'symbol' => $market['base'] . '-' . $market['quote'],
        );
        $url = $this->urls['api']['public'] . '/v1/open-interest?' . $this->urlencode($query);
        $response = $this->fetch($url, 'GET', null, null);
        //
        // {
        //   "openInterest" => "-341.19996",
        //   "symbol" => "ATOM-USDC",
        //   "time" => 1754427059775
        // }
        //
        return $this->parse_open_interest($response, $market);
    }

    public function parse_funding_rate($fundingRate, ?array $market = null): array {
        //
        // {
        //   "symbol" => "ATOM-USDC",
        //   "funding_rate" => "-0.117462885648393966",
        //   "long_rate" => "-0.189599831252923122",
        //   "short_rate" => "0.117462885648393966",
        //   "timestamp" => 1754361530209
        // }
        //
        $marketId = $this->safe_string($fundingRate, 'symbol');
        $symbol = $this->safe_symbol($marketId, $market, '-');
        $timestamp = $this->safe_integer($fundingRate, 'timestamp');
        $rate = $this->safe_string($fundingRate, 'funding_rate');
        return array(
            'info' => $fundingRate,
            'symbol' => $symbol,
            'markPrice' => null,
            'indexPrice' => null,
            'interestRate' => null,
            'estimatedSettlePrice' => null,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'fundingRate' => $this->parse_number($rate),
            'fundingTimestamp' => $timestamp,
            'fundingDatetime' => $this->iso8601($timestamp),
            'nextFundingRate' => null,
            'nextFundingTimestamp' => null,
            'nextFundingDatetime' => null,
            'previousFundingRate' => null,
            'previousFundingTimestamp' => null,
            'previousFundingDatetime' => null,
        );
    }

    public function parse_open_interest($openInterest, ?array $market = null): OpenInterest {
        //
        // {
        //   "openInterest" => "-341.19996",
        //   "symbol" => "ATOM-USDC",
        //   "time" => 1754427059775
        // }
        //
        $marketId = $this->safe_string($openInterest, 'symbol');
        $symbol = $this->safe_symbol($marketId, $market, '-');
        $openInterestAmount = $this->safe_string($openInterest, 'openInterest');
        $timestamp = $this->safe_integer($openInterest, 'time');
        return array(
            'symbol' => $symbol,
            'baseVolume' => $this->parse_number($openInterestAmount),
            'quoteVolume' => null,
            'openInterestAmount' => $this->parse_number($openInterestAmount),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'info' => $openInterest,
        );
    }

    public function fetch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
         * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
         * @param {string} $timeframe the length of time each candle represents, support '1m', '1h', '1d'
         * @param {int} [$since] timestamp in ms of the earliest candle to fetch
         * @param {int} [$limit] the maximum amount of candles to fetch
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {int} [$params->until] timestamp in ms of the latest candle to fetch
         * @return {int[][]} A list of candles ordered, open, high, low, close, volume
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $until = $this->safe_integer($params, 'until', $this->milliseconds());
        $fromTime = $since;
        if ($fromTime === null) {
            if ($limit !== null) {
                $timeframeInMilliseconds = $this->parse_timeframe($timeframe) * 1000;
                $fromTime = $this->sum($until, $timeframeInMilliseconds * $limit * -1);
            } else {
                $fromTime = 0;
            }
        }
        $fromTime = (int) floor($fromTime / 1000); // convert to seconds
        $toTime = (int) floor($until / 1000); // convert to seconds
        $params = $this->omit($params, array( 'until' ));
        $path = 'ohlcv/' . $market['baseId'] . '/' . (string) $fromTime . '/' . (string) $toTime . '/' . $this->safe_string($this->timeframes, $timeframe, $timeframe);
        $url = $this->urls['api']['public'] . '/' . $path;
        $response = $this->fetch($url, 'GET', null, null);
        //
        // array(
        //     {
        //         "close" => 51000.0,
        //         "high" => 51500.0,
        //         "low" => 50500.0,
        //         "open" => 50800.0,
        //         "timestamp" => 1640995200
        //     }
        // )
        //
        return $this->parse_ohlcvs($response, $market, $timeframe, $since, $limit);
    }

    public function parse_ohlcv($ohlcv, ?array $market = null): array {
        //
        // {
        //     "close" => 51000.0,
        //     "high" => 51500.0,
        //     "low" => 50500.0,
        //     "open" => 50800.0,
        //     "timestamp" => 1640995200
        // }
        //
        return array(
            $this->safe_timestamp($ohlcv, 'timestamp'),
            $this->safe_number($ohlcv, 'open'),
            $this->safe_number($ohlcv, 'high'),
            $this->safe_number($ohlcv, 'low'),
            $this->safe_number($ohlcv, 'close'),
            null, // volume not provided in response
        );
    }

    public function fetch_balance($params = array ()): array {
        /**
         * query for $balance and get the $amount of funds available for trading or funds locked in orders
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} $params->address the wallet $address to fetch $balance for
         * @return {array} a $balance structure
         */
        $address = $this->safe_string($params, 'address');
        if ($address === null) {
            throw new ArgumentsRequired($this->id . ' fetchBalance() requires an $address parameter');
        }
        $params = $this->omit($params, array( 'address' ));
        $path = 'v1/balance/' . $address;
        $url = $this->urls['api']['public'] . '/' . $path;
        $response = $this->fetch($url, 'GET', null, null);
        //
        // {
        //     "leverage_lp_positions" => [...],
        //     "liquid_assets" => array(
        //         array(
        //             "amount" => "1000000000",
        //             "denom" => "USDC"
        //         ),
        //         {
        //             "amount" => "50000000",
        //             "denom" => "WBTC"
        //         }
        //     ),
        //     "liquidity_positions" => [...],
        //     "perpetual_positions" => [...]
        // }
        //
        $result = array(
            'info' => $response,
            'timestamp' => null,
            'datetime' => null,
        );
        $liquidAssets = $this->safe_list($response, 'liquid_assets', array());
        for ($i = 0; $i < count($liquidAssets); $i++) {
            $balance = $liquidAssets[$i];
            $currencyId = $this->safe_string($balance, 'denom');
            $code = $this->safe_currency_code($currencyId);
            $amount = $this->safe_string($balance, 'amount');
            $account = $this->account();
            $account['free'] = $amount;
            $account['total'] = $amount;
            $result[$code] = $account;
        }
        return $this->safe_balance($result);
    }

    public function fetch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetch all trades made by the user
         * @param {string} $symbol unified $market $symbol
         * @param {int} [$since] the earliest time in ms to fetch trades for
         * @param {int} [$limit] the maximum number of trades structures to retrieve
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} $params->address the wallet $address to fetch trades for
         * @param {int} [$params->from] pagination offset, defaults to 0
         * @return {Trade[]} a list of $trade structures
         */
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchMyTrades() requires a $symbol parameter');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $address = $this->safe_string($params, 'address');
        if ($address === null) {
            throw new ArgumentsRequired($this->id . ' fetchMyTrades() requires an $address parameter');
        }
        $fromParam = $this->safe_string($params, 'from', '0');
        $size = $this->safe_string($params, 'size', $limit ? (string) $limit : '100');
        $params = $this->omit($params, array( 'address', 'from', 'size' ));
        // Convert $symbol to API format (base-quote)
        $symbolId = $market['base'] . '-' . $market['quote'];
        $path = 'trades/' . $address . '/' . $symbolId . '/' . $size . '/' . $fromParam;
        $url = $this->urls['api']['public'] . '/' . $path;
        $response = $this->fetch($url, 'GET', null, null);
        //
        // {
        //     "perpetual_position" => array(
        //         {
        //             "all_interests_paid" => "string",
        //             "amm_pool_id" => "string",
        //             "borrow_interest_paid_custody" => "string",
        //             "closing_amount" => "string",
        //             "closing_price" => "string",
        //             "closing_ratio" => "string",
        //             "collateral" => "string",
        //             "collateral_amount" => "string",
        //             "collateral_asset" => "string",
        //             "created_at" => "2019-08-24T14:15:22Z",
        //             "custody" => "string",
        //             "custody_asset" => "string",
        //             // ... more fields
        //             "txhash" => "string",
        //             "type" => "string"
        //         }
        //     ),
        //     "spot_orders" => array(
        //         {
        //             "amount" => array(
        //                 "amount" => "string",
        //                 "denom" => "string"
        //             ),
        //             "created_at" => "2019-08-24T14:15:22Z",
        //             "order_amount" => array(
        //                 "amount" => "string",
        //                 "denom" => "string"
        //             ),
        //             "order_id" => "string",
        //             "order_price" => "string",
        //             "order_type" => "string",
        //             "owner_address" => "string",
        //             "spot_price" => "string",
        //             "txhash" => "string",
        //             "type" => "string"
        //         }
        //     )
        // }
        //
        $result = array();
        // Process perpetual position trades
        $perpetualPositions = $this->safe_list($response, 'perpetual_position', array());
        for ($i = 0; $i < count($perpetualPositions); $i++) {
            $trade = $this->parse_my_trade($perpetualPositions[$i], $market);
            $result[] = $trade;
        }
        // Process spot order trades
        $spotOrders = $this->safe_list($response, 'spot_orders', array());
        for ($i = 0; $i < count($spotOrders); $i++) {
            $trade = $this->parse_my_trade($spotOrders[$i], $market);
            $result[] = $trade;
        }
        return $this->filter_by_since_limit($result, $since, $limit, 'timestamp');
    }

    public function fetch_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetch historical trades for a $symbol
         * @param {string} $symbol unified $market $symbol
         * @param {int} [$since] the earliest time in ms to fetch trades for
         * @param {int} [$limit] the maximum number of trades to return
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} $params->address the wallet $address to fetch trades for (required)
         * @param {int} [$params->from] pagination offset, defaults to 0
         * @return {Trade[]} a list of $trade structures
         */
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchTrades() requires a $symbol parameter');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $address = $this->safe_string($params, 'address');
        if ($address === null) {
            throw new ArgumentsRequired($this->id . ' fetchTrades() requires an $address parameter');
        }
        $fromParam = $this->safe_string($params, 'from', '0');
        $size = $this->safe_string($params, 'size', $limit ? (string) $limit : '100');
        $params = $this->omit($params, array( 'address', 'from', 'size' ));
        // Convert $symbol to API format (base-quote)
        $symbolId = $market['base'] . '-' . $market['quote'];
        $path = 'trades/' . $address . '/' . $symbolId . '/' . $size . '/' . $fromParam;
        $url = $this->urls['api']['public'] . '/' . $path;
        $response = $this->fetch($url, 'GET', null, null);
        //
        // {
        //     "perpetual_position" => array(
        //         {
        //             "type" => "perpetual_mtp_open",
        //             "mtp_id" => "64",
        //             "owner" => "elys1u8c28343vvhwgwhf29w6hlcz73hvq7lwxmrl46",
        //             "position" => "SHORT",
        //             "amm_pool_id" => "1",
        //             "collateral_asset" => "USDC",
        //             "collateral" => "19.754485",
        //             "open_price" => "4.345121747801747801",
        //             "created_at" => "2025-07-30T21:44:56.048Z",
        //             "txhash" => "68582DF04AE7F04302F66D937B18E2B7B181664A7C01247689473DA746DBC153"
        //         }
        //     ),
        //     "spot_orders" => array(
        //         {
        //             "type" => "tradeshield_execute_market_buy_spot_order",
        //             "order_type" => "MARKETBUY",
        //             "order_id" => "0",
        //             "order_price" => "5.354117447312775000",
        //             "order_amount" => array(
        //                 "denom" => "ATOM",
        //                 "amount" => "1"
        //             ),
        //             "owner_address" => "elys1u8c28343vvhwgwhf29w6hlcz73hvq7lwxmrl46",
        //             "created_at" => "2025-05-12T12:40:38.309Z",
        //             "txhash" => "7C8555767E7D8D492B62E132108EC4CE26DAC8D78F008611A5AE3C1FD3D2DCD5"
        //         }
        //     )
        // }
        //
        $result = array();
        // Process perpetual position trades
        $perpetualPositions = $this->safe_list($response, 'perpetual_position', array());
        for ($i = 0; $i < count($perpetualPositions); $i++) {
            $trade = $this->parse_my_trade($perpetualPositions[$i], $market);
            $result[] = $trade;
        }
        // Process spot order trades
        $spotOrders = $this->safe_list($response, 'spot_orders', array());
        for ($i = 0; $i < count($spotOrders); $i++) {
            $trade = $this->parse_my_trade($spotOrders[$i], $market);
            $result[] = $trade;
        }
        return $this->filter_by_since_limit($result, $since, $limit, 'timestamp');
    }

    public function fetch_open_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetch open orders for a $symbol
         * @param {string} $symbol unified $market $symbol
         * @param {int} [$since] the earliest time in ms to fetch orders for
         * @param {int} [$limit] the maximum number of orders to return
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} [$params->address] the wallet $address to fetch orders for
         * @return {Order[]} a list of $order structures
         */
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchOpenOrders() requires a $symbol parameter');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $address = $this->safe_string($params, 'address');
        $query = array(
            'symbol' => $market['base'] . '-' . $market['quote'],
        );
        if ($address !== null) {
            $query['address'] = $address;
        }
        $params = $this->omit($params, array( 'address' ));
        $url = $this->urls['api']['public'] . '/v1/orders/open?' . $this->urlencode($query);
        $response = $this->fetch($url, 'GET', null, null);
        //
        // {
        //   "pending_spot_orders" => null,
        //   "pending_perpetual_orders" => array(
        //     {
        //       "order_id" => "24",
        //       "owner_address" => "elys1wstfr2fx8h9tdxhs4wv4t8sjxdgrw6f9dpdpdf",
        //       "position" => "LONG",
        //       "trigger_price" => "0.000000000000000000",
        //       "collateral_denom" => "USDC",
        //       "collateral_value" => "4240.469631",
        //       "leverage" => "3.000000000000000000",
        //       "take_profit_price" => "0.000000000000000000",
        //       "stop_loss_price" => "0.000000000000000000",
        //       "pool_id" => "6",
        //       "liquidation_price" => "2513.381153809520746186",
        //       "funding_rate" => "0.000000000000000000",
        //       "borrow_interest_rate" => "0.000000000000000000",
        //       "position_size_denom" => "ETH",
        //       "position_size_value" => "3.457635083"
        //     }
        //   )
        // }
        //
        $result = array();
        // Process pending spot orders
        $spotOrders = $this->safe_list($response, 'pending_spot_orders', array());
        for ($i = 0; $i < count($spotOrders); $i++) {
            $order = $this->parse_order($spotOrders[$i], $market);
            $result[] = $order;
        }
        // Process pending perpetual orders
        $perpetualOrders = $this->safe_list($response, 'pending_perpetual_orders', array());
        for ($i = 0; $i < count($perpetualOrders); $i++) {
            $order = $this->parse_order($perpetualOrders[$i], $market);
            $result[] = $order;
        }
        return $this->filter_by_since_limit($result, $since, $limit, 'timestamp');
    }

    public function fetch_order(string $id, ?string $symbol = null, $params = array ()): array {
        /**
         * fetch a specific order by $id
         * @param {string} $id order $id
         * @param {string} $symbol unified $market $symbol
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} $params->address the wallet $address that owns the order (required)
         * @return {array} an order structure
         */
        if ($id === null) {
            throw new ArgumentsRequired($this->id . ' fetchOrder() requires an $id parameter');
        }
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchOrder() requires a $symbol parameter');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $address = $this->safe_string($params, 'address');
        if ($address === null) {
            throw new ArgumentsRequired($this->id . ' fetchOrder() requires an $address parameter');
        }
        $query = array(
            'id' => $id,
            'symbol' => $market['base'] . '-' . $market['quote'],
            'address' => $address,
        );
        $params = $this->omit($params, array( 'address' ));
        $url = $this->urls['api']['public'] . '/v1/order?' . $this->urlencode($query);
        $response = $this->fetch($url, 'GET', null, null);
        //
        // {
        //   "collateral_asset" => "USDC",
        //   "trading_asset" => "WBTC",
        //   "liability_asset" => "USDC",
        //   "custody_asset" => "WBTC",
        //   "collateral" => "21.552225",
        //   "liability" => "21.571616",
        //   "borrow_interest_paid_custody" => "0",
        //   "borrow_interest_unpaid_liability" => "19391",
        //   "custody" => "38062",
        //   "health" => "2.006222443084368180",
        //   "position" => "LONG",
        //   "amm_pool_id" => 5,
        //   "take_profit_price" => "0.000000000000000000",
        //   "take_profit_borrow_factor" => "1.000000000000000000",
        //   "funding_fee_paid_custody" => "81",
        //   "funding_fee_received_custody" => "181",
        //   "open_price" => "113500.890943575154101469",
        //   "stop_loss_price" => "58169.206608582266477003",
        //   "trading_asset_price" => "113668.427604308776796146",
        //   "pnl" => array(
        //     "denom" => "USDC",
        //     "amount" => "0.153619"
        //   ),
        //   "effective_leverage" => "1.992036442801146611",
        //   "liquidation_price" => "58022.183058726551416110",
        //   "fees" => array(
        //     "total_fees_base_currency" => "92099",
        //     "borrow_interest_fees_liability_asset" => "0",
        //     "borrow_interest_fees_base_currency" => "0",
        //     "funding_fees_liquidity_asset" => "81",
        //     "funding_fees_base_currency" => "92099"
        //   ),
        //   "id" => 125
        // }
        //
        // This is actually a perpetual $position, not a traditional order
        // We'll parse it order structure
        $position = $this->safe_string($response, 'position'); // 'LONG' or 'SHORT'
        $side = $position ? strtolower($position) : null;
        $collateral = $this->safe_string($response, 'collateral');
        $openPrice = $this->safe_string($response, 'open_price');
        $orderId = $this->safe_string($response, 'id');
        $stopLossPrice = $this->safe_string($response, 'stop_loss_price');
        $takeProfitPrice = $this->safe_string($response, 'take_profit_price');
        $cost = ($collateral && $openPrice) ? $this->number_to_string($this->parse_number($collateral) * $this->parse_number($openPrice)) : null;
        return $this->safe_order(array(
            'id' => $orderId,
            'clientOrderId' => null,
            'info' => $response,
            'timestamp' => null,
            'datetime' => null,
            'lastTradeTimestamp' => null,
            'symbol' => $symbol,
            'type' => 'market', // perpetual positions are typically $market orders
            'timeInForce' => null,
            'postOnly' => null,
            'side' => $side,
            'amount' => $collateral, // using $collateral
            'price' => $openPrice,
            'stopPrice' => $stopLossPrice,
            'triggerPrice' => null,
            'takeProfitPrice' => $takeProfitPrice,
            'cost' => $cost,
            'average' => $openPrice,
            'filled' => $collateral, // assuming $position is fully filled
            'remaining' => '0', // perpetual positions are fully filled
            'status' => 'closed', // this is an active $position, but in order terms it's "filled"
            'fee' => null,
            'trades' => null,
        ), $market);
    }

    public function fetch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetch all orders (perpetual positions) for a $symbol
         * @param {string} $symbol unified $market $symbol
         * @param {int} [$since] the earliest time in ms to fetch orders for
         * @param {int} [$limit] the maximum number of orders to return
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} [$params->address] optional $address to filter orders
         * @return {Order[]} a list of $order structures
         */
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchOrders() requires a $symbol parameter');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $address = $this->safe_string($params, 'address');
        $query = array(
            'symbol' => $market['base'] . '-' . $market['quote'],
        );
        if ($address !== null) {
            $query['address'] = $address;
        }
        $params = $this->omit($params, array( 'address' ));
        $url = $this->urls['api']['public'] . '/v1/orders?' . $this->urlencode($query);
        $response = $this->fetch($url, 'GET', null, null);
        //
        // array(
        //   {
        //     "collateral_asset" => "USDC",
        //     "trading_asset" => "WBTC",
        //     "liability_asset" => "USDC",
        //     "custody_asset" => "WBTC",
        //     "collateral" => "0.028661",
        //     "liability" => "0.058045",
        //     "borrow_interest_paid_custody" => "2486",
        //     "borrow_interest_unpaid_liability" => "721",
        //     "custody" => "42062",
        //     "health" => "823.960724878386525358",
        //     "position" => "LONG",
        //     "amm_pool_id" => 5,
        //     "take_profit_price" => "0.000000000000000000",
        //     "take_profit_borrow_factor" => "1.000000000000000000",
        //     "funding_fee_paid_custody" => "1767",
        //     "funding_fee_received_custody" => "41984",
        //     "open_price" => "107780.910665021660979213",
        //     "stop_loss_price" => "74350.528603299143254436",
        //     "trading_asset_price" => "113671.371393379478105303",
        //     "pnl" => array(
        //       "denom" => "USDC",
        //       "amount" => "47.740094"
        //     ),
        //     "effective_leverage" => "1.001200013156294978",
        //     "liquidation_price" => "139.649738172221958061",
        //     "fees" => array(
        //       "total_fees_base_currency" => "4835894",
        //       "borrow_interest_fees_liability_asset" => "2486",
        //       "borrow_interest_fees_base_currency" => "2826718",
        //       "funding_fees_liquidity_asset" => "1767",
        //       "funding_fees_base_currency" => "2009175"
        //     ),
        //     "id" => 2
        //   }
        // )
        //
        $result = array();
        for ($i = 0; $i < count($response); $i++) {
            $position = $response[$i];
            // Parse each perpetual $position $order
            $positionSide = $this->safe_string($position, 'position'); // 'LONG' or 'SHORT'
            $side = $positionSide ? strtolower($positionSide) : null;
            $collateral = $this->safe_string($position, 'collateral');
            $openPrice = $this->safe_string($position, 'open_price');
            $orderId = $this->safe_string($position, 'id');
            $stopLossPrice = $this->safe_string($position, 'stop_loss_price');
            $takeProfitPrice = $this->safe_string($position, 'take_profit_price');
            $cost = ($collateral && $openPrice) ? $this->number_to_string($this->parse_number($collateral) * $this->parse_number($openPrice)) : null;
            $order = $this->safe_order(array(
                'id' => $orderId,
                'clientOrderId' => null,
                'info' => $position,
                'timestamp' => null,
                'datetime' => null,
                'lastTradeTimestamp' => null,
                'symbol' => $symbol,
                'type' => 'market', // perpetual positions are typically $market orders
                'timeInForce' => null,
                'postOnly' => null,
                'side' => $side,
                'amount' => $collateral, // using $collateral
                'price' => $openPrice,
                'stopPrice' => $stopLossPrice,
                'triggerPrice' => null,
                'takeProfitPrice' => $takeProfitPrice,
                'cost' => $cost,
                'average' => $openPrice,
                'filled' => $collateral, // assuming $position is fully filled
                'remaining' => '0', // perpetual positions are fully filled
                'status' => 'closed', // this is an active $position, but in $order terms it's "filled"
                'fee' => null,
                'trades' => null,
            ), $market);
            $result[] = $order;
        }
        return $this->filter_by_since_limit($result, $since, $limit, 'timestamp');
    }

    public function parse_my_trade($trade, ?array $market = null): array {
        //
        // Perpetual position $trade:
        // {
        //     "all_interests_paid" => "string",
        //     "amm_pool_id" => "string",
        //     "closing_amount" => "string",
        //     "closing_price" => "string",
        //     "collateral_amount" => "string",
        //     "created_at" => "2019-08-24T14:15:22Z",
        //     "open_price" => "string",
        //     "owner" => "string",
        //     "position" => "string",
        //     "txhash" => "string",
        //     "type" => "string"
        // }
        //
        // Spot order $trade:
        // {
        //     "amount" => array(
        //         "amount" => "string",
        //         "denom" => "string"
        //     ),
        //     "created_at" => "2019-08-24T14:15:22Z",
        //     "order_amount" => array(
        //         "amount" => "string",
        //         "denom" => "string"
        //     ),
        //     "order_id" => "string",
        //     "order_price" => "string",
        //     "order_type" => "string",
        //     "owner_address" => "string",
        //     "spot_price" => "string",
        //     "txhash" => "string",
        //     "type" => "string"
        // }
        //
        $id = $this->safe_string_2($trade, 'txhash', 'order_id');
        $timestamp = $this->parse8601($this->safe_string($trade, 'created_at'));
        $symbol = $market ? $market['symbol'] : null;
        // Determine if it's a perpetual or spot $trade
        $isPerpetual = (is_array($trade) && array_key_exists('amm_pool_id', $trade));
        if ($isPerpetual) {
            // Perpetual position $trade (can be open or closed)
            $amount = $this->safe_string($trade, 'collateral'); // Use collateral position size
            $price = $this->safe_string($trade, 'open_price'); // Use open_price for perpetual positions
            $side = $this->safe_string($trade, 'position'); // 'long' or 'short'
            $type = 'market'; // perpetual positions are typically $market orders
        } else {
            // Spot order $trade
            $orderAmount = $this->safe_dict($trade, 'order_amount', array());
            $amount = $this->safe_string($orderAmount, 'amount');
            $price = $this->safe_string_2($trade, 'order_price', 'spot_price');
            $orderType = $this->safe_string($trade, 'order_type');
            $side = ($orderType === 'buy') ? 'buy' : 'sell';
            $type = 'market'; // assuming $market orders for now
        }
        $cost = ($amount && $price) ? $this->number_to_string($this->parse_number($amount) * $this->parse_number($price)) : null;
        return $this->safe_trade(array(
            'id' => $id,
            'order' => $this->safe_string($trade, 'order_id'),
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'type' => $type,
            'side' => $side,
            'amount' => $amount,
            'price' => $price,
            'cost' => $cost,
            'fee' => null, // fee information not directly available
            'takerOrMaker' => null,
        ), $market);
    }

    public function parse_order($order, ?array $market = null): array {
        //
        // Perpetual Order:
        // {
        //   "order_id" => "24",
        //   "owner_address" => "elys1wstfr2fx8h9tdxhs4wv4t8sjxdgrw6f9dpdpdf",
        //   "position" => "LONG",
        //   "trigger_price" => "0.000000000000000000",
        //   "collateral_denom" => "USDC",
        //   "collateral_value" => "4240.469631",
        //   "leverage" => "3.000000000000000000",
        //   "take_profit_price" => "0.000000000000000000",
        //   "stop_loss_price" => "0.000000000000000000",
        //   "pool_id" => "6",
        //   "liquidation_price" => "2513.381153809520746186",
        //   "funding_rate" => "0.000000000000000000",
        //   "borrow_interest_rate" => "0.000000000000000000",
        //   "position_size_denom" => "ETH",
        //   "position_size_value" => "3.457635083"
        // }
        //
        // Spot Order:
        // {
        //   "order_amount" => "string",
        //   "order_denom" => "string",
        //   "order_id" => 0,
        //   "order_price" => null,
        //   "order_target_denom" => "string",
        //   "order_type" => "string",
        //   "owner_address" => "string",
        //   "status" => "string"
        // }
        //
        $id = $this->safe_string($order, 'order_id');
        $symbol = $market ? $market['symbol'] : null;
        // Check if it's a perpetual $order (has $position field) or spot $order (has order_type field)
        $isPerpetual = (is_array($order) && array_key_exists('position', $order));
        if ($isPerpetual) {
            // Perpetual $order
            $position = $this->safe_string($order, 'position'); // 'LONG' or 'SHORT'
            $side = $position ? strtolower($position) : null;
            $amount = $this->safe_string($order, 'position_size_value');
            $triggerPrice = $this->safe_string($order, 'trigger_price');
            $price = ($triggerPrice && $triggerPrice !== '0.000000000000000000') ? $triggerPrice : null;
            $type = $price ? 'limit' : 'market';
            $status = 'open'; // perpetual orders are pending/open
        } else {
            // Spot $order
            $orderType = $this->safe_string($order, 'order_type');
            $side = ($orderType === 'MARKETBUY' || $orderType === 'LIMITBUY') ? 'buy' : 'sell';
            $amount = $this->safe_string($order, 'order_amount');
            $price = $this->safe_string($order, 'order_price');
            if ($orderType && mb_strpos($orderType, 'MARKET') !== false) {
                $type = 'market';
            } else {
                $type = 'limit';
            }
            $status = $this->safe_string($order, 'status', 'open');
        }
        $cost = ($amount && $price) ? $this->number_to_string($this->parse_number($amount) * $this->parse_number($price)) : null;
        return $this->safe_order(array(
            'id' => $id,
            'clientOrderId' => null,
            'info' => $order,
            'timestamp' => null,
            'datetime' => null,
            'lastTradeTimestamp' => null,
            'symbol' => $symbol,
            'type' => $type,
            'timeInForce' => null,
            'postOnly' => null,
            'side' => $side,
            'amount' => $amount,
            'price' => $price,
            'stopPrice' => $isPerpetual ? $this->safe_string($order, 'stop_loss_price') : null,
            'triggerPrice' => $isPerpetual ? $this->safe_string($order, 'trigger_price') : null,
            'takeProfitPrice' => $isPerpetual ? $this->safe_string($order, 'take_profit_price') : null,
            'cost' => $cost,
            'average' => null,
            'filled' => null,
            'remaining' => $amount,
            'status' => $status,
            'fee' => null,
            'trades' => null,
        ), $market);
    }
}
